import{_ as h,aw as M,ax as _,ay as Y,az as H,l as t,c as z,aA as q,aB as K,ai as Q,an as U,aj as G,ah as V,aC as W,aD as Z,aE as $}from"./AugmentMessage-BHgnxRkx.js";import{G as P}from"./graph-DDuBh4w2.js";import{l as ee}from"./layout-UrDMVz7U.js";import{i as C}from"./_baseUniq-uDqqXzFx.js";import{c as ne}from"./clone-GIaI6k5A.js";import{m as T}from"./_basePickBy-iiVghp6f.js";import"./TextAugment-CCgoKCVh.js";import"./index-B9uIMiyK.js";import"./preload-helper-iZIsTGZK.js";import"./await-Bft3-TRy.js";import"./index-B4NDmpYR.js";import"./IconButtonAugment-CsdawHyK.js";/* empty css                                                */import"./Store-CzuxPCq8.js";import"./CardAugment-Bqwu5ahx.js";import"./focusTrapStack-9JCo5vKi.js";import"./Chevron-Cl2ZClCm.js";import"./BaseTextInput-CKEk7GUD.js";import"./message-broker-CppRv-qk.js";import"./index-BuNY6jLF.js";import"./index-Bz1AJAWu.js";import"./chat-model-DaVfYv7o.js";import"./file-type-utils-CBkYZ4gj.js";import"./CalloutAugment-BUb-HAQ6.js";import"./types-DGsjtdxm.js";import"./chat-model-context-DwFUhpQk.js";import"./Markdown-F1hzawoT.js";import"./CollapseButtonAugment-CdECN-QQ.js";import"./toggleHighContrast-BIKVVoPO.js";import"./ButtonAugment-dm8Gq3Cq.js";import"./Filespan-DQTy5qup.js";import"./OpenFileButton-DcM9qoQQ.js";import"./index-Czcl53hR.js";import"./remote-agents-client-3ykFyqEs.js";import"./SuccessfulButton-CqblPP5m.js";import"./CopyButton-CYoKSKPU.js";import"./LanguageIcon-BRHvdy0u.js";import"./keypress-fD7XHdyk.js";import"./TextAreaAugment-Pjr5jpcU.js";import"./partner-mcp-utils-8KSbNsEE.js";import"./augment-logo-CnRinIIJ.js";import"./utils-BOGwHecm.js";try{N=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},(k=new N.Error().stack)&&(N._sentryDebugIds=N._sentryDebugIds||{},N._sentryDebugIds[k]="daabb8fc-91d3-4297-91fe-c8db16972a2c",N._sentryDebugIdIdentifier="sentry-dbid-daabb8fc-91d3-4297-91fe-c8db16972a2c")}catch{}var N,k;function w(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:re(e),edges:ie(e)};return C(e.graph())||(r.value=ne(e.graph())),r}function re(e){return T(e.nodes(),function(r){var n=e.node(r),d=e.parent(r),a={v:r};return C(n)||(a.value=n),C(d)||(a.parent=d),a})}function ie(e){return T(e.edges(),function(r){var n=e.edge(r),d={v:r.v,w:r.w};return C(r.name)||(d.name=r.name),C(n)||(d.value=n),d})}var s=new Map,v=new Map,A=new Map,te=h(()=>{v.clear(),A.clear(),s.clear()},"clear"),D=h((e,r)=>{const n=v.get(r)||[];return t.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),ae=h((e,r)=>{const n=v.get(r)||[];return t.info("Descendants of ",r," is ",n),t.info("Edge is ",e),e.v!==r&&e.w!==r&&(n?n.includes(e.v)||D(e.v,r)||D(e.w,r)||n.includes(e.w):(t.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),J=h((e,r,n,d)=>{t.warn("Copying children of ",e,"root",d,"data",r.node(e),d);const a=r.children(e)||[];e!==d&&a.push(e),t.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach(o=>{if(r.children(o).length>0)J(o,r,n,d);else{const c=r.node(o);t.info("cp ",o," to ",d," with parent ",e),n.setNode(o,c),d!==r.parent(o)&&(t.warn("Setting parent",o,r.parent(o)),n.setParent(o,r.parent(o))),e!==d&&o!==e?(t.debug("Setting parent",o,e),n.setParent(o,e)):(t.info("In copy ",e,"root",d,"data",r.node(e),d),t.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==d,"node!==clusterId",o!==e));const g=r.edges(o);t.debug("Copying Edges",g),g.forEach(p=>{t.info("Edge",p);const u=r.edge(p.v,p.w,p.name);t.info("Edge data",u,d);try{ae(p,d)?(t.info("Copying as ",p.v,p.w,u,p.name),n.setEdge(p.v,p.w,u,p.name),t.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):t.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",d," clusterId:",e)}catch(m){t.error(m)}})}t.debug("Removing node",o),r.removeNode(o)})},"copy"),R=h((e,r)=>{const n=r.children(e);let d=[...n];for(const a of n)A.set(a,e),d=[...d,...R(a,r)];return d},"extractDescendants"),oe=h((e,r,n)=>{const d=e.edges().filter(g=>g.v===r||g.w===r),a=e.edges().filter(g=>g.v===n||g.w===n),o=d.map(g=>({v:g.v===r?n:g.v,w:g.w===r?r:g.w})),c=a.map(g=>({v:g.v,w:g.w}));return o.filter(g=>c.some(p=>g.v===p.v&&g.w===p.w))},"findCommonEdges"),x=h((e,r,n)=>{const d=r.children(e);if(t.trace("Searching children of id ",e,d),d.length<1)return e;let a;for(const o of d){const c=x(o,r,n),g=oe(r,n,c);if(c){if(!(g.length>0))return c;a=c}}return a},"findNonClusterChild"),B=h(e=>s.has(e)&&s.get(e).externalConnections&&s.has(e)?s.get(e).id:e,"getAnchorId"),de=h((e,r)=>{if(!e||r>10)t.debug("Opting out, no graph ");else{t.debug("Opting in, graph "),e.nodes().forEach(function(n){e.children(n).length>0&&(t.warn("Cluster identified",n," Replacement id in edges: ",x(n,e,n)),v.set(n,R(n,e)),s.set(n,{id:x(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const d=e.children(n),a=e.edges();d.length>0?(t.debug("Cluster identified",n,v),a.forEach(o=>{D(o.v,n)^D(o.w,n)&&(t.warn("Edge: ",o," leaves cluster ",n),t.warn("Descendants of XXX ",n,": ",v.get(n)),s.get(n).externalConnections=!0)})):t.debug("Not a cluster ",n,v)});for(let n of s.keys()){const d=s.get(n).id,a=e.parent(d);a!==n&&s.has(a)&&!s.get(a).externalConnections&&(s.get(n).id=a)}e.edges().forEach(function(n){const d=e.edge(n);t.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),t.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let a=n.v,o=n.w;if(t.warn("Fix XXX",s,"ids:",n.v,n.w,"Translating: ",s.get(n.v)," --- ",s.get(n.w)),s.get(n.v)||s.get(n.w)){if(t.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),a=B(n.v),o=B(n.w),e.removeEdge(n.v,n.w,n.name),a!==n.v){const c=e.parent(a);s.get(c).externalConnections=!0,d.fromCluster=n.v}if(o!==n.w){const c=e.parent(o);s.get(c).externalConnections=!0,d.toCluster=n.w}t.warn("Fix Replacing with XXX",a,o,n.name),e.setEdge(a,o,d,n.name)}}),t.warn("Adjusted Graph",w(e)),j(e,0),t.trace(s)}},"adjustClustersAndEdges"),j=h((e,r)=>{if(t.warn("extractor - ",r,w(e),e.children("D")),r>10)return void t.error("Bailing out");let n=e.nodes(),d=!1;for(const a of n){const o=e.children(a);d=d||o.length>0}if(d){t.debug("Nodes = ",n,r);for(const a of n)if(t.debug("Extracting node",a,s,s.has(a)&&!s.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",r),s.has(a))if(!s.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){t.warn("Cluster without external connections, without a parent and with children",a,r);let o=e.graph().rankdir==="TB"?"LR":"TB";s.get(a)?.clusterData?.dir&&(o=s.get(a).clusterData.dir,t.warn("Fixing dir",s.get(a).clusterData.dir,o));const c=new P({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.warn("Old graph before copy",w(e)),J(a,e,c,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:s.get(a).clusterData,label:s.get(a).label,graph:c}),t.warn("New graph after copy node: (",a,")",w(c)),t.debug("Old graph after copy",w(e))}else t.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!s.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),r),t.debug(s);else t.debug("Not a cluster",a,r);n=e.nodes(),t.warn("New list of nodes",n);for(const a of n){const o=e.node(a);t.warn(" Now next level",a,o),o?.clusterNode&&j(o.graph,r+1)}}else t.debug("Done, no node has children",e.nodes())},"extractor"),F=h((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(d=>{const a=e.children(d),o=F(e,a);n=[...n,...o]}),n},"sorter"),se=h(e=>F(e,e.children()),"sortNodesByHierarchy"),L=h(async(e,r,n,d,a,o)=>{t.warn("Graph in recursive render:XAX",w(r),a);const c=r.graph().rankdir;t.trace("Dir in recursive render - dir:",c);const g=e.insert("g").attr("class","root");r.nodes()?t.info("Recursive render XXX",r.nodes()):t.info("No nodes found for",r),r.edges().length>0&&t.info("Recursive edges",r.edge(r.edges()[0]));const p=g.insert("g").attr("class","clusters"),u=g.insert("g").attr("class","edgePaths"),m=g.insert("g").attr("class","edgeLabels"),y=g.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(l){const i=r.node(l);if(a!==void 0){const f=JSON.parse(JSON.stringify(a.clusterData));t.trace(`Setting data for parent cluster XXX
 Node.id = `,l,`
 data=`,f.height,`
Parent cluster`,a.height),r.setNode(a.id,f),r.parent(l)||(t.trace("Setting parent",l,a.id),r.setParent(l,a.id,f))}if(t.info("(Insert) Node XXX"+l+": "+JSON.stringify(r.node(l))),i?.clusterNode){t.info("Cluster identified XBX",l,i.width,r.node(l));const{ranksep:f,nodesep:b}=r.graph();i.graph.setGraph({...i.graph.graph(),ranksep:f+25,nodesep:b});const E=await L(y,i.graph,n,d,r.node(l),o),S=E.elem;q(i,S),i.diff=E.diff||0,t.info("New compound node after recursive render XAX",l,"width",i.width,"height",i.height),K(S,i)}else r.children(l).length>0?(t.trace("Cluster - the non recursive path XBX",l,i.id,i,i.width,"Graph:",r),t.trace(x(i.id,r)),s.set(i.id,{id:x(i.id,r),node:i})):(t.trace("Node - the non recursive path XAX",l,y,r.node(l),c),await Q(y,r.node(l),{config:o,dir:c}))})),await h(async()=>{const l=r.edges().map(async function(i){const f=r.edge(i.v,i.w,i.name);t.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),t.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(r.edge(i))),t.info("Fix",s,"ids:",i.v,i.w,"Translating: ",s.get(i.v),s.get(i.w)),await $(m,f)});await Promise.all(l)},"processEdges")(),t.info("Graph before layout:",JSON.stringify(w(r))),t.info("############################################# XXX"),t.info("###                Layout                 ### XXX"),t.info("############################################# XXX"),ee(r),t.info("Graph after layout:",JSON.stringify(w(r)));let O=0,{subGraphTitleTotalMargin:I}=U(o);return await Promise.all(se(r).map(async function(l){const i=r.node(l);if(t.info("Position XBX => "+l+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i?.clusterNode)i.y+=I,t.info("A tainted cluster node XBX1",l,i.id,i.width,i.height,i.x,i.y,r.parent(l)),s.get(i.id).node=i,G(i);else if(r.children(l).length>0){t.info("A pure cluster node XBX1",l,i.id,i.x,i.y,i.width,i.height,r.parent(l)),i.height+=I,r.node(i.parentId);const f=i?.padding/2||0,b=i?.labelBBox?.height||0,E=b-f||0;t.debug("OffsetY",E,"labelHeight",b,"halfPadding",f),await V(p,i),s.get(i.id).node=i}else{const f=r.node(i.parentId);i.y+=I/2,t.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",f,f?.offsetY,i),G(i)}})),r.edges().forEach(function(l){const i=r.edge(l);t.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(i),i),i.points.forEach(S=>S.y+=I/2);const f=r.node(l.v);var b=r.node(l.w);const E=W(u,i,s,n,f,b,d);Z(i,E)}),r.nodes().forEach(function(l){const i=r.node(l);t.info(l,i.type,i.diff),i.isGroup&&(O=i.diff)}),t.warn("Returning from recursive render XAX",g,O),{elem:g,diff:O}},"recursiveRender"),We=h(async(e,r)=>{const n=new P({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),d=r.select("g");M(d,e.markers,e.type,e.diagramId),_(),Y(),H(),te(),e.nodes.forEach(o=>{n.setNode(o.id,{...o}),o.parentId&&n.setParent(o.id,o.parentId)}),t.debug("Edges:",e.edges),e.edges.forEach(o=>{if(o.start===o.end){const c=o.start,g=c+"---"+c+"---1",p=c+"---"+c+"---2",u=n.node(c);n.setNode(g,{domId:g,id:g,parentId:u.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(g,u.parentId),n.setNode(p,{domId:p,id:p,parentId:u.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(p,u.parentId);const m=structuredClone(o),y=structuredClone(o),X=structuredClone(o);m.label="",m.arrowTypeEnd="none",m.id=c+"-cyclic-special-1",y.arrowTypeStart="none",y.arrowTypeEnd="none",y.id=c+"-cyclic-special-mid",X.label="",u.isGroup&&(m.fromCluster=c,X.toCluster=c),X.id=c+"-cyclic-special-2",X.arrowTypeStart="none",n.setEdge(c,g,m,c+"-cyclic-special-0"),n.setEdge(g,p,y,c+"-cyclic-special-1"),n.setEdge(p,c,X,c+"-cyc<lic-special-2")}else n.setEdge(o.start,o.end,{...o},o.id)}),t.warn("Graph at first:",JSON.stringify(w(n))),de(n),t.warn("Graph after XAX:",JSON.stringify(w(n)));const a=z();await L(d,n,e.type,e.diagramId,void 0,a)},"render");export{We as render};
//# sourceMappingURL=dagre-6UL2VRFP-Ib7HcRG8.js.map
